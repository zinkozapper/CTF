# --- 1. Main Context Directives ---
user nobody;
worker_processes auto;

error_log /var/log/nginx/error.log notice;

events {
    worker_connections 1024;
}

# --- 2. Stream Block (TCP Content Switching) ---
stream {
    resolver 127.0.0.11 valid=5s;
    # 2a. Define the mapping logic
    # Map the result of our Lua script ($stream_destination) to the actual upstream address

    geo $stream_destination {
        default ''; # Declares $stream_destination as a valid variable
    }

    map $stream_destination $destination {
        http      web:8000;
        minecraft minecraft:25565;
        default   bot:9000;
    }
    log_format main '$remote_addr [$time_local] $protocol $status $bytes_sent $bytes_received';

    # 2b. The single public listener
    server {
        listen 25565;

        # üìù Lua Preread Logic: Inspect the data before proxying
        preread_by_lua_block {
            local sock = ngx.req.socket()
            if not sock then return ngx.ERROR end

                ngx.log(ngx.DEBUG, "--- Starting protocol inspection ---") -- Read the first 10 bytes for better inspection
                local data, err = sock:peek(2)

                local dest = "bot"

                if data then
                    local first_byte = data:byte(1)
                    local second_byte = data:byte(2) or 0 -- Get second byte or default to 0

                    -- 1. Check for HTTP: First byte is ASCII for G, P, D, etc.
                    if first_byte == string.byte("G") or first_byte == string.byte("P") or first_byte == string.byte("D") then
                        dest = "http"
                        elseif first_byte == 0x10 and second_byte == 0x00 then
                            dest = "minecraft"
                            ngx.log(ngx.NOTICE, "‚úÖ SUCCESS: Matched specific Minecraft handshake (0x10 0x00).")
                            elseif first_byte == 0xfe then
                                dest = "minecraft"
                                ngx.log(ngx.NOTICE, "‚úÖ SUCCESS: Matched Minecraft Legacy Ping (0xFE).")
                                end  else
                                -- If connection closed or timed out during the graceful wait, terminate.
                                if err == "closed" or err == "timeout" then
                                    ngx.log(ngx.NOTICE, "Silent/Closed connection during preread. Terminating.")
                                    return ngx.ERROR
                                    else
                                        ngx.log(ngx.NOTICE, "Unexpected Preread error: ", err)
                                        end
                                        end  ngx.var.stream_destination = dest
        }

        proxy_pass $destination;
        proxy_timeout 1h;
        access_log /var/log/nginx/stream-access.log main;
    }
}

# --- 3. HTTP Block (Required by OpenResty/Nginx) ---
http {
    include mime.types;
    default_type application/octet-stream;
    sendfile on;
    keepalive_timeout 300;

    # No server blocks needed if this proxy only handles TCP/Stream traffic,
    # but the block itself must exist.
}
