# --- 1. Main Context Directives ---
user nobody;
worker_processes auto;

error_log /var/log/nginx/error.log notice;

events {
    worker_connections 1024;
}

# -------------------------------------------------------------
# --- 2. Stream Block (TCP Content Switching - FIXED) ---
# -------------------------------------------------------------
# --- 2. Stream Block (TCP Content Switching - FINAL WORKING FIX) ---
stream {
    # Essential for dynamic Docker service names
    resolver 127.0.0.11 valid=5s;

    # 4. FINAL PASS MAP: Maps the intermediate destination back to the final SERVICE UPSTREAM
    map $stream_destination $final_service {
        http        127.0.0.1:80;           # HTTP and Bot traffic get routed here
        minecraft   minecraft:25565;      # Minecraft traffic gets routed here
        default     bot:9000;
    }

    log_format main '$remote_addr [$time_local] $protocol $status $bytes_sent $bytes_received';

    # --- A. PUBLIC LISTENER (Protocol Detector and Redirect to Internal Listener) ---
    server {
        listen 25565;

        set $original_client_ip $remote_addr;
        set $stream_destination 'bot';
        # üìù Lua Preread Logic: Remains the same, but the 'http' route now directs to 'bot'.
        preread_by_lua_block {
            local sock = ngx.req.socket()
            if not sock then return ngx.ERROR end

                ngx.log(ngx.DEBUG, "--- Starting protocol inspection ---")
                local data, err = sock:peek(2)

                local dest = "bot"

                if data then
                    local first_byte = data:byte(1)
                    local second_byte = data:byte(2) or 0

                    -- 1. Check for HTTP: This is the TCP trigger.
                    if first_byte == string.byte("G") or first_byte == string.byte("P") or first_byte == string.byte("D") then
                        dest = "http"
                        elseif first_byte == 0x10 and second_byte == 0x00 then
                            dest = "minecraft"
                            ngx.log(ngx.NOTICE, "‚úÖ SUCCESS: Matched specific Minecraft handshake (0x10 0x00).")
                            elseif first_byte == 0xfe then
                                dest = "minecraft"
                                ngx.log(ngx.NOTICE, "‚úÖ SUCCESS: Matched Minecraft Legacy Ping (0xFE).")
                                end
                                else
                                    if err == "closed" or err == "timeout" then
                                        ngx.log(ngx.NOTICE, "Silent/Closed connection during preread. Terminating.")
                                        return ngx.ERROR
                                        else
                                            ngx.log(ngx.NOTICE, "Unexpected Preread error: ", err)
                                            end
                                            end
                                            ngx.var.stream_destination = dest
        }
        proxy_protocol on;
        proxy_pass $final_service;
        proxy_timeout 1h;
        access_log /var/log/nginx/stream-access.log main;
    }
}
# -------------------------------------------------------------
# --- 3. HTTP Block (Dynamic L7 Routing) ---
# This block is the target for the 'http' service in the stream block.
# -------------------------------------------------------------
http {
    # ... other standard directives ...
    resolver 127.0.0.11 valid=5s;

    # This upstream is for your bot's internal lookup API
    upstream bot_lookup {
        server bot:9001; # Matches your bot's httpPort
    }

    server {
        # Nginx listens internally on port 80, which is the target
        # of the stream block's proxy_pass when HTTP is detected.
        listen 80;
        server_name localhost;

        # 1. Internal Location for Lookup API Call
        location /api_lookup {
            internal;
            proxy_pass http://bot_lookup/lookup;
        }

        # 2. Main Location for HTTP Requests (The actual router)
        location / {
            set $container_address "default:80";

            # 1. Perform the API lookup and set the dynamic upstream
            access_by_lua_block {
                -- Get the client IP (which is the real IP because of proxy_protocol on in the stream block)
                local ip = ngx.var.remote_addr

                -- Capture the response from the internal API
                local res = ngx.location.capture("/api_lookup?ip=" .. ip)

                if res.status == 200 then
                    local json = require("cjson")
                    local data = json.decode(res.body)

                    -- Set a new Nginx variable that proxy_pass can use
                    ngx.var.container_address = data.address
                    ngx.log(ngx.NOTICE, "Dynamic proxy address set to: ", data.address)
                    else
                        ngx.log(ngx.ERR, "API lookup failed with status: ", res.status, " for IP: ", ip)
                        -- Fallback to a default server/error page
                        ngx.var.container_address = "bot:9000"
                        end
            }

            proxy_pass http://$container_address;

            # Standard HTTP headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
}
